---
title: "Multivariate Data Analysis"
author: "Juan Pablo Zaldivar && Enric Millán && Joel Solé"
date: "2023-05-11"
output: html_document
---

```{r setup, include=F, warnings=F, echo=F}

knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo=FALSE)

YlGnBu = c("#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#253494", "#081d58")

source("plots.R")

library(dplyr)
library(plotly)
library(ggplot2)
library(qqplotr)
```

# Exploratory data analysis

```{r}
df <- read.csv2("glass.csv", header=TRUE, sep=",")
head(df)
```

```{r}
# Transform features into numeric
features <- names(df)[names(df) != "Type"]
df[features] <- lapply(df[features], as.numeric)

# Transform label as categorical
df$Type <- as.factor(df$Type)
```

```{r}
unique(df$Type)
```

```{r}
bar_plot <- plot_ly(data = df, x = ~Type,
                    color = ~Type, colors = "YlGnBu") %>%
  add_histogram() %>%
  layout(title = "Count of Types in df Dataset",
         xaxis = list(title = "Type"), yaxis = list(title = "Count"))

bar_plot
```

```{r}
# Compute correlation matrix
corr_matrix <- cor(df[, 1:9])

# Create a heatmap using Plotly
heatmap <- plot_ly(
  x = colnames(corr_matrix),
  y = colnames(corr_matrix),
  z = corr_matrix,
  type = "heatmap",
  colorscale = "YlGnBu"
)

# Add cell values to the heatmap
heatmap <- heatmap %>%
  add_annotations(
    x = rep(colnames(corr_matrix), each = length(colnames(corr_matrix))),
    y = rep(colnames(corr_matrix), length(colnames(corr_matrix))),
    text = round(corr_matrix, 2),
    showarrow = FALSE)

heatmap
```

```{r}
histogram_plots(df[, -c(10)])
```

Ba and Fe are not very common elements.

```{r}
box_plots(df[, -c(10)])
```


# Preprocesing

## Data transformation

```{r}
# Transform features into numeric
features <- names(df)[names(df) != "Type"]
df[features] <- lapply(df[features], as.numeric)

# Transform label as categorical
df$Type <- as.factor(df$Type)
```

As seen in the exploratory analysis, the Ba and Fe elements are not very common among all instances. For that reason, we have chosen to binarize those variables, setting them to 1 if the df instance contains Ba and Fe respectively (i.e. the value of the variables is greater than 0) and 0 otherwise.

```{r}
df_num <- df
# Categorize variable 'Ba'
df$Ba <- ifelse(df$Ba != 0.0, 1, 0)

# Categorize variable 'Fe'
df$Fe <- ifelse(df$Fe != 0.0, 1, 0)

df_cat <- df
```


## Missing values

```{r}
sum(is.na(df))
```

## Duplicated values

The row number 40 is a duplicate of the previous row.

```{r}
anyDuplicated(df)
df <- df[!duplicated(df),]
```


# Linear Discriminant Analysis

## Normality assumptions

```{r}
histogram_plots(df_cat[, -c(10)])
```

- K and Mg doesnt seem too normal to me

```{r}
qq_plots(df_cat[,-c(8, 9, 10)])
```


```{r}
for (i in 2:6){
  print(colnames(df_cat)[i])
  print(shapiro.test(df_cat[,i])$p.value)
}
```

```{r}
num_features <- select_if(df_cat, is.numeric)

# Detect outliers using the IQR method
outliers <- lapply(num_features, function(feature) {
  q1 <- quantile(feature, 0.25)
  q3 <- quantile(feature, 0.75)
  iqr <- q3 - q1
  lower_bound <- q1 - 1.5 * iqr
  upper_bound <- q3 + 1.5 * iqr
  outlier_rows <- which(feature < lower_bound | feature > upper_bound)
  outlier_rows
})

# Combine the outlier indexes
outlier_indexes <- unique(unlist(outliers))

# Drop the outlier rows from the "glass" dataframe
df_cat_clean <- df_cat[-outlier_indexes, ]
```

```{r}
num_features <- select_if(df_cat_clean, is.numeric)

# Perform tipification (standardization)
tipified_data <- scale(num_features)

# Convert the tipified data back to a dataframe
tipified_df <- as.data.frame(tipified_data)

# Combine the tipified numerical features with the categorical variable
tipified_df <- cbind(tipified_df, df_cat_clean$Type)
colnames(tipified_df)[ncol(tipified_df)] <- "Type"
```

```{r}
qq_plots(tipified_df[,-c(8,9,10)])
```


```{r}
for (i in 2:6){
  print(colnames(tipified_df)[i])
  print(shapiro.test(tipified_df[,i])$p.value)
}
```



## Homocedasticity assumptions


## Train-Test split













.

