---
title: "Multivariate Data Analysis"
author: "Juan Pablo Zaldivar && Enric Millán && Joel Solé"
date: "2023-05-11"
output: html_document
---

```{r setup, include=F, warnings=F, echo=F}

knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo=FALSE)

YlGnBu = c("#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#253494", "#081d58")

source("plots.R")

library(dplyr)
library(MASS)
library(plotly)
library(ggplot2)
library(qqplotr)
library(caTools)
library(biotools)

# Set the seed for reproducibility
set.seed(123)
```

# Exploratory data analysis


The given dataset consists of measurements of various chemical properties of glass samples, along with their corresponding types. The dataset contains 10 features and 214 instances.

Each row in the dataset corresponds to a specific glass sample and provides the measurements of the aforementioned features, as well as the type of glass it belongs to.

```{r}
glass <- read.csv2("glass.csv", header=TRUE, sep=",")
head(glass)
```

```{r}
# Transform features into numeric
features <- names(glass)[names(glass) != "Type"]
glass[features] <- lapply(glass[features], as.numeric)

# Transform label as categorical
glass$Type <- as.factor(glass$Type)
```

The **type** variable is evidently categorical. It provides information about the different types of glass present in the database. There are six diffrenet levels (for a more detailed explanation of each level see the appendix).

```{r}
unique(glass$Type)
```

```{r}
bar_plot <- plot_ly(data = glass, x = ~Type,
                    color = ~Type, colors = "YlGnBu") %>%
  add_histogram() %>%
  layout(title = "Count of Types in glass Dataset",
         xaxis = list(title = "Type"), yaxis = list(title = "Count"))

bar_plot
```

The dataset is pretty unbalanced. The instances of **types** 1 and 2 constitute more than $67%$ of the glass types.

```{r}
# Compute correlation matrix
corr_matrix <- cor(glass[, 1:9])

# Create a heatmap using Plotly
heatmap <- plot_ly(
  x = colnames(corr_matrix),
  y = colnames(corr_matrix),
  z = corr_matrix,
  type = "heatmap",
  colorscale = "YlGnBu"
)

# Add cell values to the heatmap
heatmap <- heatmap %>%
  add_annotations(
    x = rep(colnames(corr_matrix), each = length(colnames(corr_matrix))),
    y = rep(colnames(corr_matrix), length(colnames(corr_matrix))),
    text = round(corr_matrix, 2),
    showarrow = FALSE)

heatmap
```

```{r}
histogram_plots(glass[, -c(10)])
```

Ba and Fe are not very common elements.

```{r}
box_plots(glass[, -c(10)])
```


# Preprocesing

## Data transformation

As seen in the exploratory analysis, the Ba and Fe elements are not very common among all instances. For that reason, we have chosen to binarize those variables, setting them to 1 if the dataframe instance contains Ba and Fe respectively (i.e. the value of the variables is greater than 0) and 0 otherwise.

```{r}
# Transform features into numeric
features <- names(glass)[names(glass) != "Type"]
glass[features] <- lapply(glass[features], as.numeric)

# Transform label as categorical
glass$Type <- as.factor(glass$Type)
```


## Missing values

```{r}
sum(is.na(glass))
```

## Duplicated values

The row number 40 is a duplicate of the previous row.

```{r}
anyDuplicated(glass)
glass <- glass[!duplicated(glass),]
```

```{r}
df_cat <- glass
# Categorize variable 'Ba'
df_cat$Ba <- ifelse(glass$Ba != 0.0, 1, 0)
df_cat$Ba <- as.factor(df_cat$Ba)

# Categorize variable 'Fe'
df_cat$Fe <- ifelse(glass$Fe != 0.0, 1, 0)
df_cat$Fe <- as.factor(df_cat$Fe)

df_cat$Type <- as.factor(df_cat$Type)
```


# Discriminant Analysis

In order to perform DA, normality and homodestacity assumptions have to be validated for predictor variables (features) are said to be normally distributed and with equal covariance matrices within each class.

## Normality assumptions

```{r}
histogram_plots(df_cat[, -c(8, 9, 10)])
box_plots(df_cat[, -c(8, 9, 10)])
```

The histograms seem to approve normality for all the features except **RI**, **Mg** and **K**. The QQ-plots shown below also confirm this assumption, although, the presence of outliers is quite notorious and may have to be checked as commented further on.

_The **Mg** variable presents a lot samples with zero values, which disturbs the distribution from normality. There are two bars with a high frequency of samples, which can also be noted from the QQ-plot, making it differ from the normality line and suggesting that maybe this variable should be treated as a categorical variable._

Regarding the **K** feature, most of the samples have values in the lower range of the histogram, but there are some observations which lie an abnormal distance from the range of most frequent values, which causes the histogram to differ from the normality assumption as well as in the previous cases. Notice that the observations lie almost perfectly over the normality line for the theoretical quantiles, but the two-three samples at the top disrupt the whole normality structure.

```{r}
qq_plots(df_cat[,-c(8, 9, 10)])
```

For that reason, an outlier treatment will be conducted with the intent of validating the normality assumption for all the features in the dataset.

```{r}
# for (i in 2:6){
#   print(colnames(df_cat)[i])
#   print(shapiro.test(df_cat[,i])$p.value)
# }
```

### Aditional outlier treatment

The detection of outliers was done with the IQR method. For the lower and upper bound of non-outliers point, the value $1.5$ is used as a multiplier to determine the threshold for identifying outliers.

```{r}
num_features <- select_if(df_cat, is.numeric)

# Detect outliers using the IQR method
outliers <- lapply(num_features, function(feature) {
  q1 <- quantile(feature, 0.25)
  q3 <- quantile(feature, 0.75)
  iqr <- q3 - q1
  lower_bound <- q1 - 1.5 * iqr 
  upper_bound <- q3 + 1.5 * iqr
  outlier_rows <- which(feature < lower_bound | feature > upper_bound)
  outlier_rows
})

# Combine the outlier indexes
outlier_indexes <- unique(unlist(outliers))

# Drop the outlier rows from the "glass" dataframe
df_cat_clean <- df_cat[-outlier_indexes,]
```

```{r}
histogram_plots(df_cat_clean[, -c(8, 9, 10)])
box_plots(df_cat_clean[, -c(8, 9, 10)])
```


```{r}
qq_plots(df_cat_clean[,-c(8,9,10)])
```


## Homocedasticity assumptions

```{r}
boxM(df_cat_clean[,-c(8,9,10)], df_cat_clean$Type)
```


## Train-Test split

```{r}
# Split the dataset into training and testing sets
split <- sample.split(df_cat_clean$Type, SplitRatio = 0.66)
train <- subset(df_cat_clean, split == TRUE)
test <- subset(df_cat_clean, split == FALSE)

dim(df_cat_clean); dim(train); dim(test)
```


## LDA

```{r}
train_step <- stepclass(train[,1:7],train[,10],method="lda",direction="backward", criterion="CR")
train_step$formula
```


```{r}
mod_lda <- lda(Type~RI+Na+Mg+Al+Si+K+Ca, data=train)
# mod_lda
```

```{r}
YlGnBu_modified = c( "#edf8b1", "#7fcdbb", "#41b6c4", "#1d91c0", "#253494", "#081d58")

partimat(Type~RI+Na+Mg+Al+Si+K+Ca, data=train ,method="lda",
         nplots.vert=3, nplots.hor=3, image.colors=YlGnBu_modified)
```


### Test prediction

```{r}
test_pred <- predict(mod_lda, test)
test_pred$class == test$Type
```

```{r}
tab <- table(test$Type, test_pred$class)
tab
```

```{r}
# Correct Classification Rate (CCR)
classrate <- sum(diag(tab))/sum(tab)
classrate
```

```{r}
# Prediction Accuracy
PA <- mod_lda$prior[1]^2 + mod_lda$prior[2]^2 + mod_lda$prior[3]^2 + 
  mod_lda$prior[4]^2 + mod_lda$prior[5]^2 + mod_lda$prior[6]^2
PA
```

```{r}
ny <- sum(diag(tab))
n <- nrow(test)
k <- 6
Qlda <- ((n-ny*k)^2)/(n*(k-1))
Qlda
```



## QDA

```{r}
names(df_cat_clean)
```

```{r}
qda.fit <- qda(Type~RI+Na+Mg+Al+Si+K+Ca, data = train)
qda.fit
```












.

# Feature description

The features in the dataset are as follows:

RI: Refractive Index (continuous) - It represents the ratio of the speed of light in a vacuum to the speed of light in the glass sample. It is a measure of how much the light is bent as it passes through the glass.

Na: Sodium (continuous) - It denotes the amount of sodium (in weight percent) present in the glass.

Mg: Magnesium (continuous) - It represents the amount of magnesium (in weight percent) present in the glass.

Al: Aluminum (continuous) - It signifies the amount of aluminum (in weight percent) present in the glass.

Si: Silicon (continuous) - It denotes the amount of silicon (in weight percent) present in the glass.

K: Potassium (continuous) - It represents the amount of potassium (in weight percent) present in the glass.

Ca: Calcium (continuous) - It signifies the amount of calcium (in weight percent) present in the glass.

Ba: Barium (continuous) - It represents the amount of barium (in weight percent) present in the glass.

Fe: Iron (continuous) - It denotes the amount of iron (in weight percent) present in the glass.

Type: Type of glass (discrete) - It represents the type of glass sample. There are six distinct types ranging from 1 to 7, excluding the 4th one.

## Type varibale description

Building_windows_float_processed: This level represents glass used for building windows that has undergone a float processing method. Float processing involves floating molten glass on a bed of molten metal to produce a smooth and flat surface.

Building_windows_non_float_processed: This level represents glass used for building windows that has not undergone a float processing method. It may have been processed using alternative methods.

Vehicle_windows_float_processed: This level represents glass used for vehicle windows that has undergone a float processing method. It is specifically processed for automotive applications.

Vehicle_windows_non_float_processed: Although not present in this particular database, this level would represent glass used for vehicle windows that has not undergone a float processing method. Similar to the previous category, it may have been processed using alternative methods.

Containers: This level represents glass used for containers such as bottles or jars.

Tableware: This level represents glass used for tableware items such as plates, bowls, or glasses.

Headlamps: This level represents glass used for headlamp lenses in automotive lighting systems.
